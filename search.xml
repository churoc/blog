<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习学习笔记</title>
      <link href="/blog/2021/12/19/ji-qi-xue-xi-xue-xi-bi-ji/"/>
      <url>/blog/2021/12/19/ji-qi-xue-xi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习学习笔记"><a href="#机器学习学习笔记" class="headerlink" title="机器学习学习笔记"></a>机器学习学习笔记</h1>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记</title>
      <link href="/blog/2021/12/18/shu-ju-jie-gou-xue-xi-bi-ji/"/>
      <url>/blog/2021/12/18/shu-ju-jie-gou-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="binary-tree-c"><a href="#binary-tree-c" class="headerlink" title="binary_tree.c"></a>binary_tree.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char ElemType;typedef struct BITNode{    ElemType data;    struct BITNode *LChild, *RChild;}BITNode, *BiTree;//创建一个二叉树，约定前序遍历的方式输入void CreateBiTree(BiTree *T){    char c;    scanf("%c", &amp;c);    if(' '==c)    {        *T=NULL;    }    else    {        *T=(BITNode *)malloc(sizeof(BITNode));        (*T)-&gt;data=c;        CreateBiTree(&amp;(*T)-&gt;LChild);        CreateBiTree(&amp;(*T)-&gt;RChild);    }}void visit(char c, int level){    printf("%c 位于第%d层\n", c, level);}void PreOrderTraverse(BiTree T, int level){    if(T)    {        visit(T-&gt;data, level);        PreOrderTraverse(T-&gt;LChild, level+1);        PreOrderTraverse(T-&gt;RChild, level+1);    }}int main(){    int level=1;    BiTree T=NULL;    CreateBiTree(&amp;T);    PreOrderTraverse(T,level);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="parent-child-tree"><a href="#parent-child-tree" class="headerlink" title="parent_child_tree"></a>parent_child_tree</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef char ElemType;//孩子结点typedef struct CTNode{    int child;                       //存放孩子结点的下标    struct CTNode *next;            //指向下一个孩子结点的指针}*ChildPtr;typedef struct {    ElemType data;                   //存放树的结点内的数据    int parent;                      //存放双亲的位置    ChildPtr firstchild;             //指向第一个孩子结点；}CTBox;typedef struct{    CTBox nodes[MAX_TREE_SIZE];     //结点数组；    int r, n;}PCTREE；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="threaded-binary-tree"><a href="#threaded-binary-tree" class="headerlink" title="threaded_binary_tree"></a>threaded_binary_tree</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char ElemType;//线索存储标识位//Link(0):表示指向左右孩子的指针//Thread(1)：表示指向前驱后继的线索typedef enum {    Link, Thread}PointerTag;typedef struct BiThrNode{    char data;    struct BiThrNode *LChild, *RChild;    PointerTag Ltag;    PointerTag Rtag;}BiThrNode, *BiThrTree;//全局变量，始终指向刚刚访问过的结点BiThrTree pre;//创建一颗二叉树，约定用前序遍历输入数据void CreateBiThrTree(BiThrTree *T){    char c;    scanf("%c", &amp;c);    if(' '== c)    {        *T=NULL;    }    else    {        *T = (BiThrNode *)malloc(sizeof(BiThrNode));        (*T)-&gt;data= c;        (*T)-&gt;Ltag= Link;        (*T)-&gt;Rtag= Link;        CreateBiThrTree(&amp;(*T)-&gt;LChild);        CreateBiThrTree(&amp;(*T)-&gt;RChild);    }}//中序遍历线索化void InThreading(BiThrTree T){    if(T)    {        InThreading(T-&gt;LChild);   //递归左孩子线索化        //左空记录前驱，右空记录后继；        if(!T-&gt;LChild)            //如果该结点没有左孩子，设置Ltag为Thread，并把LChild指向刚刚访问的结点        {            T-&gt;Ltag=Thread;            T-&gt;LChild=pre;        }        if(!pre-&gt;RChild)        {            pre-&gt;Rtag=Thread;            pre-&gt;RChild=T;        }        pre = T;                         InThreading(T-&gt;RChild);   //递归右孩子线索化    }}//增加头结点；void InOrderThreading(BiThrTree *p, BiThrTree T){    *p= (BiThrNode *)malloc(sizeof(BiThrNode));        (*p)-&gt;Rtag=Thread;    (*p)-&gt;RChild=*p;    (*p)-&gt;Ltag=Link;    if(!T)    {        (*p)-&gt;LChild=*p;    }    else    {        (*p)-&gt;LChild=T;        pre = *p;        InThreading(T);                pre-&gt;Rtag=Thread;     //收尾        pre-&gt;RChild=*p;        (*p)-&gt;RChild=pre;    }}//中序遍历二叉树，非递归void InOrderTraverse_Thr(BiThrTree T){    BiThrTree p;    p = T-&gt;LChild;    while(p!=T)    {        while(p-&gt;Ltag==Link)            p=p-&gt;LChild;        printf("%c",p-&gt;data);        while(p-&gt;Rtag==Thread &amp;&amp; p-&gt;RChild!=T)        {            p=p-&gt;RChild;            printf("%c",p-&gt;data);        }        p=p-&gt;RChild;    }}int main(){    BiThrTree p, T = NULL;    CreateBiThrTree(&amp;T);    InOrderThreading(&amp;p, T);    printf("输出结果是：");    InOrderTraverse_Thr(p);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency_List"></a>Adjacency_List</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char VertexType;typedef int EdgeType;#define MAXVES 100typedef struct EdgeNode                     //边表结点{    int adjvex;    EdgeType weight;    struct EdgeNode *next;}EdgeNode; typedef struct VertexNode                    //顶点表结点{    VertexType data;    EdgeNode *firstedge;                     //边表头指针}VertexNode;typedef struct                               //图结构{    VertexNode VertexList[MAXVES];           //顶点表结点数组    int numVertexes, numEdges;}AdjList;void CreateAdjList(AdjList *G){    int i, j, k;    EdgeNode *e;    printf("输入顶点数和边数\n");    scanf("%d, %d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    for(i=0; i&lt;G-&gt;numVertexes; i++)    {        scanf("%c",&amp;G-&gt;VertexList[i].data);           //输入顶点信息        G-&gt;VertexList[i].firstedge=NULL;         //边表置空    }    for(k=0; k&lt;G-&gt;numEdges; k++)    {        printf("输入边的顶点序号\n");        scanf("%d,%d", i, j);        e=(EdgeNode*)malloc(sizeof(EdgeNode)); //生成边表结点        if(!e)            exit(0);        //头插法        e-&gt;adjvex=i;                           //边表结点的顶点数据输入        e-&gt;next=G-&gt;VertexList[i].firstedge;       //边表结点的指向边表头指针        G-&gt;VertexList[i].firstedge=e;             //修改边表头指针为e        e=(EdgeNode*)malloc(sizeof(EdgeNode));        if(!e)            exit(0);        e-&gt;adjvex=j;        e-&gt;next=G-&gt;VertexList[j].firstedge;        G-&gt;VertexList[j].firstedge=e;    }}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency_Matrix"></a>Adjacency_Matrix</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65535typedef struct{    VertexType VexList[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void CreateMGraph(MGraph *G){    int i, j, k, w;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;VexList[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w);        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Orthogonal"><a href="#Orthogonal" class="headerlink" title="Orthogonal"></a>Orthogonal</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define MAX_VERTEX_NUM 10typedef char VertexData;typedef enum{DG,DN,UDG,UDN}GraphKind;    //图的种类typedef struct ArcNode{    int tailvex, headvex;    struct ArcNode *hlink, *tlink; }ArcNode;                                //弧表结点typedef struct VertexNode{    VertexData data;    ArcNode *firstin, *firstout;}VertexNode;                             //顶点表结点typedef struct {    VertexNode vertexList[MAX_VERTEX_NUM];   //顶点表数组    int vernum, arcnum;    GraphKind kind;}OrthList;                               //十字邻表void CreateOrthList(OrthList *g){    int i, j, k;    ArcNode *e;    printf("请输入顶点数和弧数\n");    scanf("%d,%d", &amp;g-&gt;vernum, &amp;g-&gt;arcnum);    for(i=0; i&lt;g-&gt;vernum; i++)    {        printf("请输入顶点信息\n");        scanf("%c", &amp;g-&gt;vertexList[i].data);        g-&gt;vertexList[i].firstin=NULL;        g-&gt;vertexList[i].firstout=NULL;    }    for(k=0; k&lt;g-&gt;arcnum; k++)    {        printf("请输入边的关联点下标");        scanf("%d,%d", &amp;i, &amp;j);              //i是弧尾，j是弧头        e=(ArcNode*)malloc(sizeof(ArcNode));        if(!e)            exit(0);        //头插法        e-&gt;headvex=j;                         //插入在顶点i的出边，顶点j的入边        e-&gt;tailvex=i;            e-&gt;tlink=g-&gt;vertexList[i].firstout;               g-&gt;vertexList[i].firstout=e;                e-&gt;hlink=g-&gt;vertexList[j].firstin;               g-&gt;vertexList[j].firstin=e;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BFSTranverse-AdjMatric"><a href="#BFSTranverse-AdjMatric" class="headerlink" title="BFSTranverse_AdjMatric"></a>BFSTranverse_AdjMatric</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char VertexType;typedef int EdgeType;typedef int ElemType;#define MAXVEX 100#define INFINITY 65535#define FALSE 0#define TRUE 1#define MAX 10int visit[MAX];typedef struct QNode{    ElemType data;    struct QNode *next;}QNode, *QueuePrt;//定义结点结构，结点指针typedef struct{    QueuePrt front, rear;}LinkQueue;      //定义链式队列结构，结构包括队头指针和队尾指针typedef struct{    VertexType vexs[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void InitQueue(LinkQueue *q){    q-&gt;front=q-&gt;rear=(QueuePrt)malloc(sizeof(QNode));    if( !q-&gt;front )        exit(0);    q-&gt;front-&gt;next= NULL;}void InsertQueue(LinkQueue *q, ElemType e){    QueuePrt p;    p = (QueuePrt)malloc(sizeof(QNode));    if(!p)        exit(0);    p-&gt;data = e;    p-&gt;next = NULL;    q-&gt;rear-&gt;next = p;    q-&gt;rear = p;}void DeleteQueue(LinkQueue *q, ElemType *e){    QueuePrt p;    if(q-&gt;front == q-&gt;rear)    {        return;                           //?    }    p = q-&gt;front-&gt;next;    *e = p-&gt;data;    q-&gt;front-&gt;next = p-&gt;next;    if( q-&gt;rear == p )    {        q-&gt;rear = q-&gt;front;    }    free(p);    p = NULL;}int QueueEmpty(LinkQueue q){    if(q.front == q.rear)        return 1;    else        return 0;}void CreateMGraph(MGraph *G){    int i, j, k;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;vexs[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d", &amp;i, &amp;j);        G-&gt;arc[i][j]=1;        G-&gt;arc[j][i]=G-&gt;arc[i][j];       }}void BFSTraverse(MGraph G){    int i, j;    LinkQueue Q;    for(i=0; i&lt;G.numVertexes; i++)    {        visit[i]=FALSE;    }    InitQueue(&amp;Q);    for(i=0; i&lt;G.numVertexes; i++)    {        if(!visit[i])        {            printf("%c", G.vexs[i]);            visit[i]=TRUE;            InsertQueue(&amp;Q, i);            while(!QueueEmpty(Q))            {                DeleteQueue(&amp;Q, &amp;i);                for(j=0; j&lt;G.numVertexes; j++)                {                    if(G.arc[i][j]==1 &amp;&amp; !visit[j])                    {                        printf("%c", G.vexs[j]);                        visit[j]=TRUE;                        InsertQueue(&amp;Q, j);                    }                }            }        }    }}int main(){    MGraph G;    CreateMGraph(&amp;G);    BFSTraverse(G);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DFSTraverse-AdjList"><a href="#DFSTraverse-AdjList" class="headerlink" title="DFSTraverse_AdjList"></a>DFSTraverse_AdjList</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char VertexType;typedef int EdgeType;#define MAXVES 100#define TRUE 1#define FALSE 0#define MAX 10int visit[MAX];typedef struct EdgeNode                     //边表结点{    int adjvex;    EdgeType weight;    struct EdgeNode *next;}EdgeNode; typedef struct VertexNode                    //顶点表结点{    VertexType data;    EdgeNode *firstedge;                     //边表头指针}VertexNode;typedef struct                               //图结构{    VertexNode VertexList[MAXVES];           //顶点表结点数组    int numVertexes, numEdges;}AdjList;void CreateAdjList(AdjList *G){    int i, j, k;    EdgeNode *e;    printf("输入顶点数和边数\n");    scanf("%d, %d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)    {        scanf("%c",&amp;G-&gt;VertexList[i].data);           //输入顶点信息        G-&gt;VertexList[i].firstedge=NULL;         //边表置空    }    fflush(stdin);    printf("输入边的顶点序号\n");    for(k=0; k&lt;G-&gt;numEdges; k++)    {        scanf("%d,%d", &amp;i, &amp;j);        e=(EdgeNode*)malloc(sizeof(EdgeNode)); //生成边表结点        if(!e)            exit(0);        //头插法        e-&gt;adjvex=i;                           //边表结点的顶点数据输入        e-&gt;next=G-&gt;VertexList[i].firstedge;       //边表结点的指向边表头指针        G-&gt;VertexList[i].firstedge=e;             //修改边表头指针为e        e=(EdgeNode*)malloc(sizeof(EdgeNode));        if(!e)            exit(0);        e-&gt;adjvex=j;        e-&gt;next=G-&gt;VertexList[j].firstedge;        G-&gt;VertexList[j].firstedge=e;    }}  void DFS(AdjList G, int i){    EdgeNode *p;    visit[i]=TRUE;    printf("%c", G.VertexList[i].data);    p=G.VertexList[i].firstedge;    while(p)    {        if(!visit[p-&gt;adjvex])            DFS(G, p-&gt;adjvex);        p=p-&gt;next;    }}void DFSTraverse(AdjList G){    int i;    for(i=0; i&lt;G.numVertexes; i++)        visit[i] = FALSE;    for(i=0; i&lt;G.numVertexes; i++)        if(!visit[i])            DFS(G, i);} int main(){    AdjList G;    CreateAdjList(&amp;G);    DFSTraverse(G);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MiniSpanTree-Kruskal"><a href="#MiniSpanTree-Kruskal" class="headerlink" title="MiniSpanTree_Kruskal"></a>MiniSpanTree_Kruskal</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define EdgeMAX 15typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65535typedef struct{    int begin;    int end;    int weight;}Edge, EdgeList[EdgeMAX];typedef struct{    VertexType VexList[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void CreateMGraph(MGraph *G){    int i, j, k, w;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;VexList[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w);        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void TransEdge( EdgeList edge , MGraph G ){    int i , j  , k = 0  ;    Edge t ;    for( i = 0 ; i &lt; G.numVertexes ; i++ )        for(  j = i + 1 ; j &lt; G.numVertexes ; j++ )            if( G.arc[ i ][ j ] &gt; 0 &amp;&amp; G.arc[ i ][ j ] &lt; INFINITY )            {                edge[ k ].begin = i ;                edge[ k ].end = j ;                edge[ k ].weight = G.arc[ i ][ j ] ;                k++ ;            }    for( i = 0 ; i &lt; G.numEdges - 1 ; i++ )        for( j = 0 ; j &lt; G.numEdges - i - 1 ; j++ )            if( edge[ j ].weight &gt; edge[ j + 1 ].weight )            {                t = edge[ j ] ;                edge[ j ] = edge[ j+ 1 ] ;                edge[ j+ 1 ] = t ;            }}int Find(int *parent, int f){    while(parent[f]&gt;0)        f=parent[f];    return f;}void MiniSpanTree_Kruskal( MGraph G)  //每次选择最小权值的边，判断边的起始点是否同源，即选择此边后是否会形成闭环{    int i, m, n;    EdgeList edge;    int parent[MAXVEX];             //定义一个家谱    TransEdge(edge, G);             //转换为边集数组，同时按权值进行排序    for(i=0;i&lt;G.numVertexes;i++)        parent[i]=0;    for(i=0;i&lt;G.numEdges;i++)    {        n=Find(parent, edge[i].begin);   //找到begin点的祖宗        m=Find(parent, edge[i].end);     //找到end点的祖宗        if(n!=m)        {            parent[n]=m;            printf("(%d,%d)-%d\n",edge[i].begin,edge[i].end, edge[i].weight);        }    }    for(i=0;i&lt;G.numVertexes;i++)    {        printf("%d",parent[i]);    }}int main( void ){    MGraph G ;    CreateMGraph( &amp;G ) ;    MiniSpanTree_Kruskal( G ) ;    return 0 ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MiniSpanTree-Prim"><a href="#MiniSpanTree-Prim" class="headerlink" title="MiniSpanTree_Prim"></a>MiniSpanTree_Prim</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define EdgeMAX 15typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65535typedef struct{    int begin;    int end;    int weight;}Edge, EdgeList[EdgeMAX];typedef struct{    VertexType VexList[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void CreateMGraph(MGraph *G){    int i, j, k, w;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;VexList[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w);        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void TransEdge( EdgeList edge , MGraph G ){    int i , j  , k = 0  ;    Edge t ;    for( i = 0 ; i &lt; G.numVertexes ; i++ )        for(  j = i + 1 ; j &lt; G.numVertexes ; j++ )            if( G.arc[ i ][ j ] &gt; 0 &amp;&amp; G.arc[ i ][ j ] &lt; INFINITY )            {                edge[ k ].begin = i ;                edge[ k ].end = j ;                edge[ k ].weight = G.arc[ i ][ j ] ;                k++ ;            }    for( i = 0 ; i &lt; G.numEdges - 1 ; i++ )        for( j = 0 ; j &lt; G.numEdges - i - 1 ; j++ )            if( edge[ j ].weight &gt; edge[ j + 1 ].weight )            {                t = edge[ j ] ;                edge[ j ] = edge[ j+ 1 ] ;                edge[ j+ 1 ] = t ;            }}int Find(int *parent, int f){    while(parent[f]&gt;0)        f=parent[f];    return f;}void MiniSpanTree_Kruskal( MGraph G)  //每次选择最小权值的边，判断边的起始点是否同源，即选择此边后是否会形成闭环{    int i, m, n;    EdgeList edge;    int parent[MAXVEX];             //定义一个家谱    TransEdge(edge, G);             //转换为边集数组，同时按权值进行排序    for(i=0;i&lt;G.numVertexes;i++)        parent[i]=0;    for(i=0;i&lt;G.numEdges;i++)    {        n=Find(parent, edge[i].begin);   //找到begin点的祖宗        m=Find(parent, edge[i].end);     //找到end点的祖宗        if(n!=m)        {            parent[n]=m;            printf("(%d,%d)-%d\n",edge[i].begin,edge[i].end, edge[i].weight);        }    }    for(i=0;i&lt;G.numVertexes;i++)    {        printf("%d",parent[i]);    }}int main( void ){    MGraph G ;    CreateMGraph( &amp;G ) ;    MiniSpanTree_Kruskal( G ) ;    return 0 ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ShortestPath-Dijkstra"><a href="#ShortestPath-Dijkstra" class="headerlink" title="ShortestPath_Dijkstra"></a>ShortestPath_Dijkstra</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define MAXVEX 9#define INFINITY 65535typedef char VertexType;typedef int EdgeType;typedef int Pathmatrix[MAXVEX];typedef int ShortPathTable[MAXVEX];typedef struct{    VertexType VexList[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void CreateMGraph(MGraph *G){    int i, j, k, w;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;VexList[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w);        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void ShortestPath_Dijkstra(MGraph G, int v0, Pathmatrix *P, ShortPathTable *D){                                               //P记录上位点，D记录到v0的最短路径    int v,w,min,k;    int final[MAXVEX];                          //判断是否求得到某点的最短路径    for(v=0; v&lt;G.numVertexes; v++)    {        final[v]=0;                             //初始化为0，所有点最短路径都没有取得            (*D)[v]=G.arc[v0][v];        (*P)[v]=0;    }    final[0]=1;                                 //v0点不需要求最短路径    (*D)[v0]=0;    for(v=1;v&lt;G.numVertexes;v++)    {        min=INFINITY;        for(w=0;w&lt;G.numVertexes;w++)            //寻找离v0最近的点        {            if(!final[w] &amp;&amp; (*D)[w]&lt;min)            {                k=w;                min=(*D)[w];            }        }        printf("%d-&gt;%d\n",(*P)[k],k);        final[k]=1;        for(w=0;w&lt;G.numVertexes;w++)            //更新到v0的最短路径，以及“上位点”        {            if(!final[w] &amp;&amp; min+G.arc[k][w]&lt;(*D)[w])            {                (*D)[w]=min+G.arc[k][w];                (*P)[w]=k;            }        }    }}int main(){    MGraph G;    Pathmatrix P;    ShortPathTable D;    CreateMGraph(&amp;G);    ShortestPath_Dijkstra(G, 0, &amp;P, &amp;D);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ShortestPath-Floyd"><a href="#ShortestPath-Floyd" class="headerlink" title="ShortestPath_Floyd"></a>ShortestPath_Floyd</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define MAXVEX 9#define INFINITY 65535typedef char VertexType;typedef int EdgeType;typedef int Pathmatrix[MAXVEX][MAXVEX];typedef int ShortPathTable[MAXVEX][MAXVEX];typedef struct{    VertexType VexList[MAXVEX];      //顶点表    EdgeType arc[MAXVEX][MAXVEX]; //边表    int numVertexes, numEdges;    //顶点数和边数}MGraph;void CreateMGraph(MGraph *G){    int i, j, k, w;    printf("输入顶点数和边数\n");    scanf("%d,%d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);    fflush(stdin);    printf("请输入顶点信息\n");    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //读入顶点    {        scanf("%c", &amp;G-&gt;VexList[i]);    }    fflush(stdin);    for(i=0; i&lt;G-&gt;numVertexes; i++)                 //初始化邻接矩阵        for(j=0; j&lt;G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=INFINITY;        }    printf("请输入边的下标i，j和权值w\n");    for(k=0; k&lt;G-&gt;numEdges; k++)                    //读入边，建立邻接矩阵    {        scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w);        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void ShortPath_Floyd(MGraph G, Pathmatrix *P, ShortPathTable *D){    int v, w, k;    for(v=0;v&lt;G.numVertexes;v++)    {        for(w=0;w&lt;G.numVertexes;w++)        {            (*D)[v][w]=G.arc[v][w];            (*P)[v][w]=w;        }    }    for(k=0;k&lt;G.numVertexes;k++)    {        for(v=0;v&lt;G.numVertexes;v++)        {            for(w=0;w&lt;G.numVertexes;w++)            {                if((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])                {                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];                    (*P)[v][w]=(*P)[v][k];                }            }        }    }}int main(){    int v, w, k;    MGraph G;    Pathmatrix P;    ShortPathTable D;    CreateMGraph(&amp;G);    ShortPath_Floyd(G, &amp;P, &amp;D);        printf("请输入起始点\n");    scanf("%d%d",&amp;v,&amp;w);    printf("\n%d -&gt; %d 的最小路径为；%d\n", v, w, D[v][w]);    k = P[v][w];    printf("path: %d", v);//打印起点    while(k != w)    {        printf("-&gt; %d", k);//打印中间点        k = P[k][w];     }    printf("-&gt; %d\n", w);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过客</title>
      <link href="/blog/2021/12/17/markdown-mo-ban/"/>
      <url>/blog/2021/12/17/markdown-mo-ban/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>过客</title>
      <link href="/blog/2021/12/17/guo-ke/"/>
      <url>/blog/2021/12/17/guo-ke/</url>
      
        <content type="html"><![CDATA[<p>　　总有一些人,原本只是生命的过客,后来却成了记忆的常客。</p><p>　　这句话初次看到是在屏保上，但是道出的无奈却让我记忆深刻，尽管时隔多年，仍牢记于心，空暇之余，拿出来放在脑海里细细品读，常常颇有感慨。生命的过客很多，或是从小到大的玩伴，却敌不过成长的冲刷，慢慢沦为路人，或是一位恩重如山的师长，终会分别于一个阶段的终点，或是彼时相依为伴的同学，或是比赛的队友，或是一个热心帮助的陌生人等等，有的深交过，有的不过是相视一笑，然后擦肩而过，不管怎样，我都觉得他们一定对现在的我的塑造有着不可或缺的作用，杨绛先生曾言，少了任何一个过去都不将是现在的我，同样，少了任何一个过客都不将是现在的我。</p><p>　　但是过客有别，毕竟有的深交，相知相识甚至相爱，但有的或许之间的交集仅在于一场交易，所以有人成为了常客，有人被冲散在记忆的浪尖，我想，我或许该把我的常客们写成散文，有文字来记叙我们的故事，记录他对我的影响，但是我不想注明是谁，仅当作一个鲜活的性格，因为我碰到重复性格的人很多，往往用一个常客竟然可以大致的揣测另一个的性格，尽管每个人都是特殊的，但是有趣的灵魂万里挑一，大多数还是具有普遍性的普通人。同样，我想把冲散的陌生人写成小说，来演绎他一个不经意的举动引起我的思考，对我哪怕是细枝末节，但也可能改变了我的人生轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
